@page "/"
@using Lapo.Services

<PageTitle>Home</PageTitle>

<MudButton @onclick="ScanAsync">Scan</MudButton>

@code
{
    [Inject] ConfigurationService ConfigurationService { get; set; } = null!;
    [Inject] CsvService CsvService { get; set; } = null!;
    [Inject] DatabaseService DatabaseService { get; set; } = null!;

    readonly Dictionary<string, List<dynamic>> _scan = new();
    Dictionary<string, List<dynamic>> _prevScan = new();

    protected override Task OnInitializedAsync() => ScanAsync();

    async Task ScanAsync()
    {
        _scan.Clear();

        var tables = await ConfigurationService.ReadAsync<List<string>>("Tables") ?? [];
        foreach (var table in tables)
        {
            var rows = await DatabaseService.QueryAsync(table);
            _scan[table] = rows;
        }

        if (!_prevScan.Any())
        {
            _prevScan = new(_scan);
            return;
        }

        var diffResult = LoadDiff();
        var mergedData = Merge(diffResult);

        CsvService.Write(mergedData);

         _prevScan = new(_scan);
    }

    (Dictionary<string, List<dynamic>> Added, Dictionary<string, List<dynamic>> Removed, Dictionary<string, List<(dynamic OldRow, dynamic NewRow)>> Updated) LoadDiff()
    {
        var addedRows = new Dictionary<string, List<dynamic>>();
        var removedRows = new Dictionary<string, List<dynamic>>();
        var updatedRows = new Dictionary<string, List<(dynamic OldRow, dynamic NewRow)>>();

        foreach (var table in _prevScan.Keys)
        {
            if (!_scan.ContainsKey(table)) continue;

            var prevRows = _prevScan[table];
            var currentRows = _scan[table];

            var prevDict = prevRows.ToDictionary(row => row.Id);
            var currentDict = currentRows.ToDictionary(row => row.Id);

            // Righe aggiunte
            var added = currentRows.Where(row => !prevDict.ContainsKey(row.Id)).ToList();
            if (added.Any()) addedRows[table] = added;

            // Righe rimosse
            var removed = prevRows.Where(row => !currentDict.ContainsKey(row.Id)).ToList();
            if (removed.Any()) removedRows[table] = removed;

            // // Righe aggiornate
            // var updated = currentRows
            //     .Where(row => prevDict.TryGetValue(row.Id, out var oldRow) && !oldRow.Equals(row))
            //     .Select(row => (OldRow: prevDict[row.Id], NewRow: row))
            //     .ToList();

            // if (updated.Any()) updatedRows[table] = updated;
        }

        return (addedRows, removedRows, updatedRows);
    }

    static List<dynamic> Merge((Dictionary<string, List<dynamic>> Added, Dictionary<string, List<dynamic>> Removed, Dictionary<string, List<(dynamic OldRow, dynamic NewRow)>> Updated) elements)
    {
        var mergedList = new List<dynamic>();

        foreach (var table in elements.Added.Keys)
        {
            mergedList.AddRange(elements.Added[table].Select(row => AddOperation(row, table, "ADD")));
        }

        foreach (var table in elements.Removed.Keys)
        {
            mergedList.AddRange(elements.Removed[table].Select(row => AddOperation(row, table, "DELETE")));
        }

        foreach (var table in elements.Updated.Keys)
        {
            mergedList.AddRange(elements.Updated[table].Select(pair => AddOperation(pair.NewRow, table, "UPDATE")));
        }

        return mergedList
            .OrderBy(row => row.TableName)
            .ThenBy(row => row.Id)
            .ToList();
    }

    static dynamic AddOperation(dynamic row, string tableName, string operation)
    {
        IDictionary<string, object> expando = new System.Dynamic.ExpandoObject();
    
        foreach (var prop in (IDictionary<string, object>)row)
        {
            expando[prop.Key] = prop.Value;
        }
    
        expando["TableName"] = tableName;
        expando["Operation"] = operation;

        return expando;
    }

}
