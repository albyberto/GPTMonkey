@page "/"
@using System.Data
@using System.Linq.Expressions
@using Lapo.Mud.Services

<PageTitle>Home</PageTitle>

<MudButton @onclick="ScanAsync" Variant="Variant.Outlined" ButtonType="ButtonType.Button" StartIcon="@Icons.Material.Outlined.Search" Color="Color.Primary">Scan</MudButton>
@if (_diff.Count == 0)
{
    <MudText Typo="Typo.h6">No changes detected</MudText>
}
else
{
    @foreach (var tableName in _gridData.Keys)
    {
        <MudText Typo="Typo.h2">@tableName</MudText>
        
        <MudDataGrid Items="@_gridData[tableName]" T="IDictionary<string, object>" Filterable="true" Dense="true" Hover="true" Bordered="true">
            <Columns>
                @foreach (var column in _columns[tableName])
                {
                    <PropertyColumn Title="@column.Key"
                                    Property="@(GetPropertyLambdaExpression<IDictionary<string, object>, object>(column.Key))">
                    </PropertyColumn>
                }
            </Columns>
            <PagerContent>
                <MudDataGridPager T="IDictionary<string, object>" />
            </PagerContent>
        </MudDataGrid>
    }
    
}

@code
{
    [Inject] ConfigurationService ConfigurationService { get; set; } = null!;
    [Inject] CsvService CsvService { get; set; } = null!;
    [Inject] DatabaseService DatabaseService { get; set; } = null!;

    readonly Dictionary<string, DataTable> _lastScan = [];
    Dictionary<string, DataTable> _previousScan = [];
    Dictionary<string, List<DataRow>> _diff = [];
    
    private Dictionary<string, List<Dictionary<string, object>>> _gridData = new(); // Grid data
    private Dictionary<string, Dictionary<string, Type>> _columns = new(); // Dynamic columns
    protected override Task OnInitializedAsync() => ScanAsync();

    async Task ScanAsync()
    {
        _lastScan.Clear();

        var tables = await ConfigurationService.ReadAsync<List<string>>("Tables") ?? [];
        foreach (var table in tables)
        {
            var rows = await DatabaseService.QueryAsync(table);
            _lastScan.Add(table, rows);
        }

        if (!_previousScan.Any())
        {
            _previousScan = new(_lastScan);
            return;
        }

        _diff.Clear();
        _diff = LoadDiff(_previousScan, _lastScan);
        BuildTable();
        
        var csv = _diff
            .SelectMany(x => x.Value)
            .OrderBy(x => x["Table"])
            .ThenBy(x => x["Id"])
            .ThenBy(x => x["Operation"])
            .ToList();
        
        CsvService.Write(csv);

        _previousScan = new(_lastScan);
    }
    
    void BuildTable()
    {
        var tables = _diff.Keys.ToList(); // Usa le tabelle presenti in _diff
        var newGridData = new Dictionary<string, List<Dictionary<string, object>>>();
        var newColumns = new Dictionary<string, Dictionary<string, Type>>();

        foreach (var table in tables)
        {
            if (!_diff.TryGetValue(table, out var dataRows) || dataRows.Count == 0)
                continue;

            var firstRow = dataRows[0];
            
            var columns = firstRow.Table.Columns
                .Cast<DataColumn>()
                // .Where(col => col.ColumnName != "Table" && col.ColumnName != "Id") // ⬅️ Exclude columns Table and Id
                .ToDictionary(col => col.ColumnName, col => col.DataType);
            
            newColumns[table] = columns;

            var rows = dataRows.Select(row =>
                columns.Keys.ToDictionary(colName => colName, colName => row[colName])).ToList();

            newGridData[table] = rows
                .OrderBy(x => x["Table"])
                .ThenBy(x => x["Id"])
                .ThenBy(x => x["Operation"])
                .ToList();;
        }

        _gridData = newGridData;
        _columns = newColumns;
        StateHasChanged();
    }


    static Dictionary<string, List<DataRow>> LoadDiff(Dictionary<string, DataTable> previousScan, Dictionary<string, DataTable> lastScan)
    {
        var diff = new Dictionary<string, List<DataRow>>();
        
        foreach (var table in lastScan.Keys)
        {
            if (!previousScan.TryGetValue(table, out var previous)) continue;
            EnhanceDataTable(previous);

            var last = lastScan[table];
            EnhanceDataTable(last);

            var previousRows = previous.AsEnumerable().ToList();
            var lastRows = last.AsEnumerable().ToList();

            var previousDict = previousRows.ToDictionary(row => row["Id"]);
            var lastDict = lastRows.ToDictionary(row => row["Id"]);

            var added = lastRows.Where(row => !previousDict.ContainsKey(row["Id"])).ToList();
            foreach (var row in added) row["Operation"] = "ADDED";

            var removed = previousRows.Where(row => !lastDict.ContainsKey(row["Id"])).ToList();
            foreach (var row in removed) row["Operation"] = "REMOVED";

            var updatedOld = previousRows
                .Where(row => lastDict.ContainsKey(row["Id"]) && !row.ItemArray.SequenceEqual(lastDict[row["Id"]].ItemArray))
                .ToList();
            foreach (var row in updatedOld) row["Operation"] = "UPDATED_OLD";

            var updatedNew = lastRows
                .Where(row => previousDict.ContainsKey(row["Id"]) && !row.ItemArray.SequenceEqual(previousDict[row["Id"]].ItemArray))
                .ToList();
            foreach (var row in updatedNew) row["Operation"] = "UPDATED_NEW";
            
            var acc = new List<DataRow>();
            acc.AddRange(added);
            acc.AddRange(removed);
            acc.AddRange(updatedOld);
            acc.AddRange(updatedNew);
            foreach (var row in acc) row["Table"] = table;
            
            diff[table] = acc;
        }

        return diff;
    }

    static void EnhanceDataTable(DataTable previous)
    {
        const string table = "Table";
        if (!previous.Columns.Contains(table))
        {
            previous.Columns.Add(table, typeof(string));
            previous.Columns[table]?.SetOrdinal(0);                
        }

        const string operation = "Operation";
        if (previous.Columns.Contains(operation)) return;
        
        previous.Columns.Add(operation, typeof(string));
        previous.Columns[operation]?.SetOrdinal(1);
    }
    
    static Expression<Func<T, TP>> GetPropertyLambdaExpression<T, TP>(string propertyName)
    {
        var param = Expression.Parameter(typeof(T), "x");
        var keyProperty = typeof(T).GetProperty("Item");
        var indexArgument = Expression.Constant(propertyName);
        var propertyAccess = Expression.MakeIndex(param, keyProperty, [indexArgument]);
        var lambdaExpression = Expression.Lambda<Func<T, TP>>(propertyAccess, param);

        return lambdaExpression;
    }
}
